---
title: "3. 타입 알아보기"
description: "Go언어의 타입에 대해 알아봅니다."
date: 2018-07-18T09:27:52+09:00
categories: [
    "Go",
    "Development"
]
tags: [
    "Go Tutorial",
    "Go",
    "golang",
    "Go언어",
    "프로그래밍"
]
keywords: [
    "Go언어",
    "golang",
    "프로그래밍",
    "Tutorial",
    "자료형",
    "Type",
    "Static Type",
    "type alias"
]
image: "post/Go/Tutorial/cover.jpg"
prev: "/2018-07-16/2.-환경변수-설정-및-개발환경-구축하기"
---

## 기본 데이터 타입
**Go**의 기본 데이터 타입은 크게 3가지로 나눌 수 있습니다.  

- **숫자**
    - `int` `int8` `int16` `int32` `int64`  *: 정수를 나타내는 타입*
    - `uint` `uint8` `uint16` `uint32` `uint64` `uintptr` *: 부호가 없는 정수를 나타내는 타입*
    - `float32` `float64`  *: 소수를 나타내는 타입*
    - `complex64` `complex128`  *: 복소수를 나타내는 타입*
    - `byte`  *: `uint8`과 같고 바이트 코드를 나타내는 타입*
    - `rune`  *: `int32`와 같고 유니코드를 타나내는 타입*
- **문자열**
    - `string` *: 문자열을 나타내는 타입*
- **불리언**
    - `bool` *: 불리언 값을 나타내는 타입*

`int`나 `uint`는 시스템에 따라 `int64`, `uint64` 혹은 `int32`, `uint32`로 사용됩니다.

### 기본 데이터 타입의 변수 선언

```go
var boolean bool // 'var 변수명 타입' 꼴로 변수를 선언할 수 있습니다.
boolean = true // '=' 을 통하여 변수에 값을 대입할 수 있습니다.
var str string = "hello" // 물론 선언과 초기화를 함께 할 수도 있습니다.
var i, j, k int = 10, 20, 30 // 같은 타입의 변수들을 나열하여 한 번에 선언과 초기화를 할 수 있습니다.
var n = 1000 // 타입을 생략하면 할당되는 값에 따라 타입이 추론됩니다.
s := "This is string!!" // ':=' 을 사용하면 var과 타입 모두를 생략할 수 있습니다. 단, 함수 내부에서만 사용 가능합니다.
```

## 컬렉션 타입
**Go**의 기본 데이터 타입을 활용한 컬렉션 타입인 Array, Slice, Map에 대해 알아보도록 하겠습니다.

- **Array**  
Array(배열)는 연속된 메모리 공간에 동일한 타입의 데이터를 순차적으로 저장하는 자료구조입니다. **Go** 역시 대부분의 프로그래밍 언어처럼 0, 1, 2, 3... 순서로 인덱스가 생성됩니다(Zero based array).

```go
var arr1 [3]int // 'var 변수명 [길이]타입' 형태로 배열을 선언할 수 있습니다.
a[0] = 10
a[1] = 20
a[2] = 30

var arr2 = [3]int{1, 2, 3} // 배열 선언과 초기화를 동시에 할 수 있습니다.
arr3 := [...]int{3, 2, 1, 0} // [...]을 사용하면 길이를 직접 지정하지 않고도 배열을 생성할 수 있습니다.

fmt.Println(arr2[1]) // 출력: 2
```
- **Slice**  
slice는 배열과 유사하지만 길이가 가변적입니다. `append` 함수를 이용하여 요소를 추가할 수 있습니다. slice에 대한 자세한 내요은 후에 다루도록 하겠습니다.

```go
var slice1 []int // 'var 변수명 []타입' 형태로 슬라이스를 선언할 수 있습니다.
                            // 단, 이와 같이 선언하면 len과 cap이 0인 nil 슬라이스가 생성됩니다.

slice2 := make([]int, 5, 5) // 'make([]자료형, 길이[, 용량])' 함수를 이용하여 슬라이스를 생성할 수 있습니다.
                                            // 용량은 생략 가능하며, 생략 시 용량은 길이와 같아집니다.  

var slice3 = []int{1, 2, 3} // 슬라이스 역시 선언과 초기화를 동시에 할 수 있습니다.

slice3 = append(slice3, 4)

fmt.Println(slice3[3]) // 출력: 4
```
- **Map**  
Map은 키와 값이 한 쌍으로 이루어진 자료구조입니다. Map은 해시테이블을 구현하여 키에 대응하는 값을 쉽고 빠르게 찾을 수 있습니다.

```go
var m1 map[string]int // 'var 변수명 map[키 타입]값 타입' 형태로 선언할 수 있습니다.
	// 맵 역시 이와 같이 선언하면 nil 맵이 생성됩니다.

m2 := make(map[int]string) // 'make(map[키 타입]값 타입)' 함수를 이용하여 맵을 생성할 수 있습니다.
m2[1] = "hello world"      // '변수명[키] = 값' 형태로 값을 대입할 수 있습니다.

var m3 = map[int]bool{
    1: true,
    2: false,
} // 맵 역시 선언과 동시에 초기화를 할 수 있습니다.

exist, val := m3[0] // 존재하지 않는 키에 대해선 값 타입의 기본 값(Zero Value)이 반환됩니다.

fmt.Println(exist, val) // false false
fmt.Println(m1 == nil)  // true
fmt.Println(m3[1])      // true
```

## Type Definition vs Type Alias
**Go**에서 타입을 만들기 위한 두 가지 방법에 대해 알아보겠습니다.

### 타입 정의(Type Definition)
타입 정의는 말 그대로 새로운 타입을 정의하는 것 입니다. 어려운 내용은 아니니 바로 코드를 보고 설명드리도록 하겠습니다.

```go
package main

import (
	"fmt"
	"reflect"
)

type Number int // Number 타입 정의

func (n *Number) Increase(num int) { // Number 타입에 메서드 추가
	*n = *n + Number(num)
}

func main() {
	var num Number = 32 // Number 타입 변수 생성

	fmt.Println(num) // 32
	num.Increase(10)
	fmt.Println(num) // 42
	fmt.Println(reflect.TypeOf(num)) // main.Number
}
```

타입 정의를 위해선 `type` 키워드를 사용해야 합니다. 위는 `type` 키워드를 사용하여 `int` 타입을 `Number`라는 새로운 타입으로 정의한 코드 입니다. 타입 정의를 사용하면 완전히 새로운 타입이 정의 되고, 로컬 패키지에서 정의가 됐기 때문에 메서드 역시 추가할 수 있습니다. `type` 키워드는 다음 시간에 알아볼 구조체와 인터페이스를 선언할 때 사용되기도 합니다.

## 타입 별칭(Type Alias)
그렇다면 타입 별칭(type alias)는 무엇이고 언제 사용하는 것일까요? 타입 별칭은 엄밀하게 말하면 새로운 타입을 만들진 않습니다. 말 그대로 특정 타입에 대해 별칭을 지어주는 것 입니다. 이는 `go 1.9`에서 등장하였으며, 코드의 점진적인 유지보수를 보다 편리하게 만들기 위해서 등장하였습니다.

```go
package OldPackage

import "NewPackage"

type OldAPI = NewPackage.NewAPI // OldAPI 타입은 NewPackage의 NewAPI 타입을 가리키게 됩니다.
```

 코드를 유지보수하며 새로운 API를 개발하는 중에 기존 API를 사용하고 있는 모든 코드를 수정하는 것은 매우 불편합니다. 함수와 변수는 기존 문법을 사용하여 코드의 대규모 수정을 피할수 있었지만, 타입의 경우 대입이 불가능하기 때문에 유지보수 측면에서 불편함이 있었습니다. 하지만 위 코드처럼 타입 별칭을 사용하면 `OldAPI` 타입이 `NewPackage.NewAPI` 타입의 별칭이 되어 코드의 대규모 수정을 피할 수 있고, 이로인해 유지보수를 보다 편리하게 할 수 있습니다.

## :tada:다음 편:tada:
이번 시간엔 **Go**의 기본 데이터 타입과 컬렉션에 대해 살펴봤습니다. 다음 시간엔 조금 더 심화된 타입인 구조체와 인터페이스에 대해 알아보도록 하겠습니다.  

## 추신
**Go Tutorial**에선 훑어보기 느낌으로 포스팅이 진행되다보니, 추후에 포스팅을 하겠다고 자주 말씀드린 것 같습니다:cry:. 시간이 되는 대로 꼭 포스팅을 할 예정이니 [공지](/categories/공지)에 추후 포스팅 예정에 대한 리스트를 참고해 주시면 감사하겠습니다.